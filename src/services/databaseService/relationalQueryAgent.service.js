const fs = require("fs");
const path = require("path");
const sequelize = require("../../config/sequelize.config");
const { generateText } = require("../openaiServices/openai.service");
const {
  semanticQueryWithContextFunction,
} = require("../../config/functionDeclaration/relationalFunctions");

// Importación de los modelos definidos en src/models/index.js
const models = require("../../models/database");

// Caching for the schema summary to avoid reading the file repeatedly.
let cachedSchemaSummary = null;

/**
 * Reads the database schema summary (or model summary) from the file `dbSchemaSummary.md`
 * located in the `src/config/dbContext` folder.
 *
 * @returns {Promise<string>} The content of the schema summary.
 */
async function getDatabaseSchemaSummary() {
  if (cachedSchemaSummary) return cachedSchemaSummary;
  const filePath = path.join(
    __dirname,
    "../../config/dbContext/dbSchemaSummary.md"
  );
  try {
    const schema = await fs.promises.readFile(filePath, "utf8");
    cachedSchemaSummary = schema;
    return schema;
  } catch (error) {
    console.error("Error reading database schema summary:", error);
    throw error;
  }
}

/**
 * Sanitizes the generated query object.
 * Aquí se podría agregar validación adicional según el método y opciones permitidas.
 *
 * @param {object} queryObject - The query object generated by OpenAI.
 * @returns {object} The sanitized query object.
 */
function sanitizeSequelizeQuery(queryObject) {
  const allowedMethods = ["findAll", "findOne", "count", "findAndCountAll"];
  if (!allowedMethods.includes(queryObject.method)) {
    throw new Error(`Method "${queryObject.method}" is not allowed.`);
  }
  return queryObject;
}

/**
 * Executes a query using the specified Sequelize model.
 *
 * @param {object} queryObject - An object containing:
 *    - model: string, the model name (e.g., "User", "Organization")
 *    - method: string, the Sequelize method to execute (e.g., "findAll")
 *    - options: object, the query options to pass to the method
 * @returns {Promise<any>} The result of the query.
 */
async function executeSequelizeQuery(queryObject) {
  try {
    const { model, method, options } = sanitizeSequelizeQuery(queryObject);
    if (!models[model]) {
      throw new Error(`Model "${model}" not found.`);
    }
    if (typeof models[model][method] !== "function") {
      throw new Error(`Method "${method}" is not valid for model "${model}".`);
    }
    return await models[model][method](options);
  } catch (error) {
    console.error("Error executing Sequelize query:", error);
    throw error;
  }
}

/**
 * Generates a Sequelize query from a natural language prompt using the OpenAI API.
 * The model summary (or schema) is provided as context via a system message.
 * The output is expected in JSON format with a key "sequelizeQuery" that contains:
 *    - model: string (e.g., "User")
 *    - method: string (e.g., "findAll")
 *    - options: object (e.g., { where: { name: "John" } })
 *
 * The final query is then executed using the corresponding Sequelize model and its result is returned.
 *
 * @param {string} userPrompt - The natural language description of the desired query.
 * @returns {Promise<any>} The result of the executed Sequelize query.
 */
async function generateSQLQuery(userPrompt) {
  try {
    if (!userPrompt || typeof userPrompt !== "string") {
      throw new Error("Invalid user prompt provided.");
    }

    // Retrieve the schema summary.
    const schemaSummary = await getDatabaseSchemaSummary();

    // Build the system message with the model/schema context.
    const systemMessage = {
      role: "system",
      content: `Sequelize Models Summary:\n${schemaSummary}`,
    };

    // Build the user message with instructions for generating a Sequelize query.
    const userMessage = {
      role: "user",
      content: `
You are a Sequelize expert. Convert the following natural language description into a precise Sequelize query.
Generate a JSON object with a key "sequelizeQuery" that includes:
- model: the name of the model to query (e.g., "User", "Organization", etc.)
- method: the Sequelize method to use (e.g., "findAll", "findOne")
- options: an object with the query options (for example, a "where" clause)
Remember to use backticks for model or attribute names if needed and do not include any SQL syntax.
Description: ${userPrompt}
      `.trim(),
    };

    // Define the expected JSON Schema for the output.
    const jsonSchema = {
      type: "object",
      properties: {
        sequelizeQuery: {
          type: "object",
          properties: {
            model: {
              type: "string",
              description:
                "The name of the Sequelize model to query (e.g., 'User', 'Organization').",
            },
            method: {
              type: "string",
              description:
                "The Sequelize method to use (e.g., 'findAll', 'findOne').",
            },
            options: {
              type: "object",
              description:
                "The query options to pass to the Sequelize method (e.g., { where: { name: 'John' } }).",
            },
          },
          required: ["model", "method"],
          additionalProperties: true,
        },
      },
      additionalProperties: false,
      required: ["sequelizeQuery"],
    };

    // Call the OpenAI API with the messages and structured output requirements.
    const result = await generateText("", {
      model: "o3-mini",
      max_tokens: 5000,
      max_completion_tokens: 5000,
      reasoningEffort: "high",
      jsonSchema,
      functions: [semanticQueryWithContextFunction],
      messages: [systemMessage, userMessage],
    });

    // Handle potential function call from OpenAI for a contextualized query.
    if (Array.isArray(result) && result.length > 0 && result[0].function) {
      const toolCall = result[0];
      if (toolCall.function.name === "generate_contextualized_sql_query") {
        const args = JSON.parse(toolCall.function.arguments);
        const finalQueryObject =
          await generateContextualizedSQLQueryWithExecution(args.userPrompt);
        const finalResult = await executeSequelizeQuery(finalQueryObject);
        return finalResult;
      }
    }

    // Otherwise, extract the final query object from the response.
    const queryObject = result.sequelizeQuery;
    const queryResult = await executeSequelizeQuery(queryObject);
    return queryResult;
  } catch (error) {
    console.error("Error generating Sequelize query:", error);
    throw error;
  }
}

/**
 * Decomposes a complex natural language prompt into sub-queries to gather additional context.
 *
 * @param {string} userPrompt - The complex natural language prompt.
 * @returns {Promise<string[]>} An array of sub-query strings.
 */
async function decomposePromptForContext(userPrompt) {
  const decompositionPrompt = `
You are a Sequelize expert. Decompose the following prompt into the fewest necessary sub-queries 
that gather only the essential context needed to generate a complete Sequelize query.

When decomposing, consider the following:
- Use backticks instead of double quotation marks.
- Only generate sub-queries if the additional context is absolutely required.
- If retrieving the full dataset is not necessary, include a LIMIT clause.
- Consider ambiguities in search criteria (e.g., similar user names).
- Each sub-query should be a complete Sequelize query snippet that can be executed independently.

Return the answer in JSON format with a key "subQueries" that is an array of strings.

Prompt: "${userPrompt}"
  `.trim();

  const jsonSchema = {
    type: "object",
    properties: {
      subQueries: {
        type: "array",
        items: { type: "string" },
        description: "List of sub-queries providing additional context.",
      },
    },
    additionalProperties: false,
    required: ["subQueries"],
  };

  const result = await generateText(decompositionPrompt, {
    model: "o3-mini",
    max_tokens: 5000,
    max_completion_tokens: 5000,
    reasoningEffort: "high",
    jsonSchema,
  });

  return result.subQueries;
}

/**
 * Executes each sub-query to fetch additional context from the database.
 *
 * @param {string[]} subQueries - An array of Sequelize query snippets.
 * @returns {Promise<string>} A combined context string with results from sub-queries.
 */
async function executeSubQueries(subQueries) {
  const contextResults = [];

  for (const querySnippet of subQueries) {
    try {
      // Here, we assume the sub-query snippet is a raw Sequelize query (in JSON format)
      // For simplicity, we'll execute it the same way as the main query.
      const queryObject = JSON.parse(querySnippet);
      const result = await executeSequelizeQuery(queryObject);
      contextResults.push(
        `Query: ${JSON.stringify(queryObject)} -> Result: ${JSON.stringify(
          result
        )}`
      );
    } catch (error) {
      console.error(`Error executing sub-query: ${querySnippet}`, error);
      contextResults.push(
        `Query: ${querySnippet} -> Result: Error executing query`
      );
    }
  }

  return contextResults.join("\n");
}

/**
 * Generates a final Sequelize query from a complex prompt by:
 * 1. Decomposing the prompt into sub-queries for additional context.
 * 2. Executing these sub-queries to gather context from the database.
 * 3. Enriching the original prompt with the additional context.
 * 4. Calling generateSQLQuery with the enriched prompt to obtain the complete Sequelize query.
 *
 * @param {string} userPrompt - The original complex natural language prompt.
 * @returns {Promise<object>} The final generated Sequelize query object.
 */
async function generateContextualizedSQLQueryWithExecution(userPrompt) {
  console.log("Generating contextualized Sequelize query with execution...");
  try {
    const subQueries = await decomposePromptForContext(userPrompt);
    const additionalContext = await executeSubQueries(subQueries);
    const enrichedPrompt = `${userPrompt}. Additional context from database queries:\n${additionalContext}`;
    const finalQueryObject = await generateSQLQuery(enrichedPrompt);
    return finalQueryObject;
  } catch (error) {
    console.error(
      "Error generating contextualized Sequelize query with execution:",
      error
    );
    throw error;
  }
}

module.exports = {
  generateSQLQuery,
};
