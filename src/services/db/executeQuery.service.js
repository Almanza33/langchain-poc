const { DataTypes } = require("sequelize");
const sequelize = require("../../config/sequelize.config");
const models = require("../../models/db");

/**
 * Recursively resolves model references in the "include" options.
 * (Existing function, not modified here)
 */
function resolveInclude(includeOption) {
  if (Array.isArray(includeOption)) {
    return includeOption.map((item) => resolveInclude(item));
  } else if (typeof includeOption === "object" && includeOption !== null) {
    if (includeOption.model && typeof includeOption.model === "string") {
      const resolvedModel = models[includeOption.model];
      if (!resolvedModel) {
        throw new Error(`Included model "${includeOption.model}" not found`);
      }
      includeOption = { ...includeOption, model: resolvedModel };
    }
    if (includeOption.include) {
      includeOption.include = resolveInclude(includeOption.include);
    }
    return includeOption;
  } else {
    return includeOption;
  }
}

/**
 * Transforms attribute expressions generated by the language model.
 * If an attribute is an array where the first element is an object with 'fn' and 'col',
 * it converts that into a Sequelize function call.
 *
 * @param {Array} attributes - The attributes array from the query options.
 * @returns {Array} The transformed attributes array.
 */
function transformAttributes(attributes) {
  if (!Array.isArray(attributes)) return attributes;
  return attributes.map((attr) => {
    if (
      Array.isArray(attr) &&
      attr.length === 2 &&
      typeof attr[0] === "object" &&
      attr[0] !== null &&
      "fn" in attr[0] &&
      "col" in attr[0]
    ) {
      return [sequelize.fn(attr[0].fn, sequelize.col(attr[0].col)), attr[1]];
    }
    return attr;
  });
}

/**
 * Executes a query using the specified Sequelize model.
 *
 * @param {object} queryObject - An object containing:
 *    - model: string, the model name (e.g., "User", "Organization")
 *    - method: string, the Sequelize method to execute (e.g., "findAll")
 *    - options: object, the query options to pass to the method
 * @returns {Promise<any>} The result of the query.
 */
async function executeQuery(queryObject) {
  console.log("Executing Sequelize query with object:", queryObject);
  try {
    const { model, method, options } = queryObject;
    if (!models[model]) {
      throw new Error(`Model "${model}" not found.`);
    }
    if (typeof models[model][method] !== "function") {
      throw new Error(`Method "${method}" is not valid for model "${model}".`);
    }

    // Copy options to avoid mutation.
    let resolvedOptions = { ...options };

    // Transform attributes if present
    if (resolvedOptions.attributes) {
      resolvedOptions.attributes = transformAttributes(
        resolvedOptions.attributes
      );
    }

    // Resolve any model references in the include option.
    if (resolvedOptions.include) {
      resolvedOptions.include = resolveInclude(resolvedOptions.include);
    }

    console.log(`Calling ${model}.${method} with options:`, resolvedOptions);
    const result = await models[model][method](resolvedOptions);
    console.log("Query executed successfully. Result:", result);
    return result;
  } catch (error) {
    console.error("Error executing Sequelize query:", error);
    throw error;
  }
}

module.exports = { executeQuery };
